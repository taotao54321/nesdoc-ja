CPU割り込み
===========

(原文: [CPU interrupts - Nesdev wiki](http://wiki.nesdev.com/w/index.php?title=CPU_interrupts&oldid=7502))

このページでは MOS 6502 CPU の割り込み処理を詳しく説明する。6502の割り
込みの基本的な部分については、
[the MOS 6502 Programming Manual](http://users.telenet.be/kim1-6502/6502/proman.html)
などを見よ。


割り込み処理の詳細
------------------

NMI入力はエッジセンシティブ(信号が high->low に切り替わるとき反応)であ
り、一方IRQ入力はレベルセンシティブ(low 信号レベルに反応)である。どち
らの入力も low であるときアクティブとみなされる。

NMI入力は*エッジ検出器*に接続されている。このエッジ検出器は各CPUサイク
ルの
[φ2](http://wiki.nesdev.com/w/index.php/CPU_pin_out_and_signal_description)
(つまり、各サイクルの後半)でNMIラインの状態をポーリングし、あるサイク
ルで high、次サイクルで low になったら内部信号を発生する。内部信号は
エッジが検出された次のサイクルのφ1で high になり、NMIが処理されるまで
high のままになる。

IRQ入力は*レベル検出器*に接続されている。あるサイクルのφ2でIRQ入力が
low レベルであることが検出されたら、次サイクルのφ1で内部信号が発生
し、そのサイクルの間だけ high になる(言い換えると、前サイクルのφ2で
IRQ入力が low である限り high のままになる)。

エッジ検出器とレベル検出器の出力は特定のタイミングでポーリングされ、処
理待ちの割り込みが検出される。ほとんどの命令においては、このポーリング
は命令の最終サイクルで、次命令のオペコードをフェッチする前に行われる。
このポーリングで割り込みが検出された場合、次に実行される「命令」は割り
込みシーケンスとなる。

多くの資料は割り込みが命令の最終サイクルでポーリングされると主張してい
るようだが、これが正しいのはエッジ/レベル検出器の出力についてのみだ。
先の記述から導かれるように、本当に重要なのは*最後から2番目のサイクルの
終わり*における割り込みラインの状態だ。

もし命令の終わりでNMIとIRQが両方処理待ちになっていると、NMIが処理さ
れ、IRQの処理待ち状態は忘れられる(後のポーリングで再度検出される可能性
が高いが)。

割り込みシーケンス自体は割り込みのポーリングを行わない。つまり、割り込
みハンドラは他の割り込みが処理される前に少なくとも1命令実行される。


CLI, SEI, PLP 後の遅延IRQ応答
-----------------------------

RTI 命令は直ちにIRQ禁止状態に影響する。IRQが処理待ちになっている状態で
RTI が実行されて I フラグがクリアされると、CPUは RTI の実行終了後直ち
にIRQハンドラを呼び出す。これは RTI が割り込みポーリング前にスタックか
ら I フラグを復帰するためだ。

一方、CLI, SEI, PLP 命令は割り込みポーリング*後*に I フラグを変更する
(全ての2サイクル命令が第1サイクルの終わりに割り込みラインをポーリング
するのと同様)。つまり、これらの命令は実質的にIRQを次命令の後まで遅延し
うる。例えば、IRQが処理待ちになっていて現在 I フラグがセットされている
ときに CLI を実行すると、IRQハンドラが呼び出される前に CLI の次の命令
も実行される。

[テストROMイメージ](http://wiki.nesdev.com/w/index.php/Emulator_tests#CPU)
により、エミュレータがこの振る舞いを実装しているかテストできる。


分岐命令と割り込み
------------------

分岐命令はより微妙なポーリング動作をする。割り込みは第2サイクル(オペラ
ンドのフェッチ)前に常にポーリングされる。加えて、ページ境界をまたぐ分
岐が発生すると、PC の上位Byteを修正するサイクルの前に割り込みがポーリ
ングされる(分岐命令のサイクル単位の処理については
[[1]](http://nesdev.com/6502_cpu.txt)を見よ)。どちらのタイミングで検出
された割り込みも(最初のタイミングのみで検出されたものも含め)CPU割り込
みを発生させる。


割り込みハイジャック
--------------------

MOS 6502 とその拡張である
[2A03/2A07](http://wiki.nesdev.com/w/index.php/CPU) には奇妙な振る舞い
があり、異なる種類の割り込みが非常に近いタイミングで発生した場合、一方
が他方を部分的に乗っ取ることがありうる。

例えば、NMIが BRK 命令の最初の4サイクルの間に発生すると、BRK 命令は最
初は通常の動作(PC がインクリメントされ、ステータスレジスタに B フラグ
をセットしたものがスタックに積まれる)を行うが、次に実行される分岐先は
IRQ/BRKベクタではなくNMIベクタとなる:

```
[] はCPUサイクル。[...] は BRK オペコードのフェッチより前のサイクル。

* でマークされた期間にNMIが発生すると、IRQ/BRKルーチンの代わりにNMI
ルーチンへ飛ぶ:

     ********************
[...][BRK][BRK][BRK][BRK][BRK][BRK][BRK]
```

BRK 命令をサイクル単位で見ると、このようになる

```
 #  address R/W description
--- ------- --- -----------------------------------------------
 1    PC     R  オペコードをフェッチし、PC をインクリメント
 2    PC     R  次のByteを読み取り(そして結果を捨て)、PC をインクリメント
 3  $0100,S  W  PC 上位Byteをスタックに積み、S をデクリメント
 4  $0100,S  W  PC 下位Byteをスタックに積み、S をデクリメント
*** この時点で割り込み信号の状態によって使われる割り込みベクタが決まる***
 5  $0100,S  W  P を(B フラグをセットして)スタックに積み、S をデクリメント
 6   $FFFE   R  PC 下位Byteをフェッチし、I フラグをセット
 7   $FFFF   R  PC 上位Byteをフェッチ
```

同様に、NMIがIRQを乗っ取ることもありうるし、IRQがBRKを乗っ取ることもあ
りうる(後者は同じ割り込みベクタを使うので影響は目に見えないが)。全ての
種類の割り込みのサイクル単位の処理は本質的には BRK のそれに似ている(ス
タックにステータスレジスタが積まれるときに B bitがセットされることと、
PC がインクリメントされることを除けば)。

### IRQ/NMI のサイクル単位の処理

BRK との類似点を強調するため、IRQ/NMIのサイクル単位の処理
([Visual 6502](http://visual6502.org/) より)を示す。RESETも同様のシー
ケンスを実行する(ただし、メモリへの書き込みは行わずにスタックポインタ
を3回デクリメントする)。RESET時に常に I フラグがセットされるのはこれが
理由だ。

```
 #  address R/W description
--- ------- --- -----------------------------------------------
 1    PC     R  オペコードをフェッチ(し、それを捨てる - $00 (BRK) は強
                制的にオペコードレジスタに入る)
 2    PC     R  次のByteを読み取る(PC インクリメントが省略されているの
                で、実際は上と同じことをする。結果は同様に捨てる。)
 3  $0100,S  W  PC 上位Byteをスタックに積み、S をデクリメント
 4  $0100,S  W  PC 下位Byteをスタックに積み、S をデクリメント
*** この時点で割り込み信号の状態によって使われる割り込みベクタが決まる***
 5  $0100,S  W  P を(B フラグを*クリア*して)スタックに積み、S をデクリメント
 6   A       R  PC 下位Byteをフェッチ (IRQでは A = FFFE, NMIでは A = FFFA),
                I フラグをセット
 7   A       R  PC 上位Byteをフェッチ (IRQでは A = FFFF, NMIでは A = FFFB)
```


Notes
-----

* 上記の割り込みハイジャックとIRQ応答の振る舞いは
  [cpu_interrupts_v2](http://wiki.nesdev.com/w/index.php/Emulator_tests)
  テストROMでテストされている。
* PPUからのVBlank NMIに関するより奇妙な振る舞いについては、
  [PPU frame timing](http://wiki.nesdev.com/w/index.php/PPU_frame_timing)
  を見よ。
* B ステータスフラグはCPU内部には物理的に存在せず、BRKおよびNMI/IRQに
  よりステータスレジスタがスタックに積まれるときに bit4 の異なる値とし
  て現れるだけである。
* 割り込みハイジャック動作の原因に関するより技術的な解説については、
  [Visual6502 の記事](http://visual6502.org/wiki/index.php?title=6502_BRK_and_B_bit)
  を見よ。
